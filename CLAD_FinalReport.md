# Title: Designing Aerial Stream Crossings for Pipelines with Python

Contributors: Christopher Bordlemay Padilla, Lindsey Matoi, Amina Rahill-Marier, Desiree Sausele

## How to make the code work:
In order for the code to run, please make sure that the excel read-in is saved in the same folder as this python code. The read-in file name, located in the beginning of the python code section, should be updated. However, it should not be replaced by a path; it should simply contain the name of the excel file that needs to be read.


## Introduction:
In temperate regions of the world, where temperatures do not go below the freezing point, potable water distribution system piping is typically designed and constructed at shallow depths beneath grade.  Specifically in areas of the developing world of those temperate zones, the distribution of potable water is a critical for sustenance farming, for drinking water, and for life in general. When a pipeline must cross difficult terrain such as a river, stream, landslide gully, or rocky gulch, piping can be installed on or above ground. In situations like these, an aerial crossing, a pipeline passing over the obstacle, is a viable method of traversing when excavation is impossible due to lack of proper construction equipment or when it is cost prohibitive to excavate due to bedrock. Aerial crossings are difficult design challenges for engineers working to design and install a water system for these remote areas. This report presents a method for collecting field data, from engineers, surveyors, and members of the community, to calculate an engineered solution to cross the most difficult sections of a distribution system, the aerial crossing.

## Background:
This report will focus on the structural components of an aerial crossing and present an automated method of calculation, in Python code, that will assist the field engineer in constructing a water distribution pipeline across difficult sections of the system.  Each crossing has its own unique characteristics, whether it be a stream crossing with suitable rocks for anchorage on either side, or clay soils needing concrete poured for anchorage, or uneven banks on either side of a creek, or a landslide gully/chute needing crossing.  There are, however, common components to each crossing that the field engineer can calculate and provide to the contractor on-site that will facilitate construction.  Often, a field engineer will encounter rudimentary aerial crossings in majority of the world, such as sticks propping up a pipeline, barbed-wire attempting to suspend a pipeline, or rocks/slab of concrete providing bases for crossings.  Although the goal of suspending the pipeline across the difficult section may have been achieved, it is a short term accomplishment without proper engineering.  Floods, or even normal rains during the rainy season, will quickly raise stream levels and washout aerial crossings and leave a section of a community or potentially a whole community without water.
Common characteristics of an aerial crossing that will be addressed in this report are as follows:
* The aerial crossing must be high enough to not be snagged by debris floating down the stream at its maximum flood level, or by land sliding rocks and boulders, preferably 2m above the high water mark as reported by the community members
* The cable supporting the pipeline must be adequately anchored on stable ground at both ends
* The aerial crossing must be level or nearly so (same elevation on either end). This is an assumption that is being made to simplify the engineering calculations. It is likely possible to design crossings that are mildly inclined, but these would still be restricted by the rotational angle the pipe would be able to accommodate without leaking. From a structural point of view, however, it is likely that the crossing could be built non-level. Further explorations and calculations supporting this design could be explored in future work.
* The cable supporting the pipeline must be strong enough to support the weight of itself, the pipe, the water in the pipe, as well as the forces generated by wind and swaying
* The pipe is securely fastened to the suspending cable, either by wire or clamps of some sort
* The pipe is typically made of galvanized steel, typically available locally, and will resist UV light and machetes


In general, the engineer will calculate the requirements of the suspension cable that will support the pipeline passing over the obstacle, which must be available locally.  The engineer will subsequently calculate the needs of the anchors on either side of the crossing, utilizing a combination of rocks, materials found locally, and concrete.

## Design Constraints:
A typical design constraint with aerial crossings in water distribution systems is the length of the span.  The longer the length of the obstacle needing crossing, a thicker cable will be required due to the added weight of pipeline, water, attaching anchors, and cable itself.  This report will attempt to determine the maximum span each cable size can safely handle.  Coinciding with this constraint is the availability of cable of necessary thickness in local stores.

Another constraint relates to the proper construction of the crossing and the understanding of the design by the contractor.  Such constraints can be overcome by properly training the contractor and providing them with the necessary tools to provide tension to the suspension cable.

The engineer should look for alternative areas to cross an obstacle to either find a suitable location to dig through or to find suitable anchor locations. An aerial crossing should be avoided if at all possible if conditions allow for digging through the obstacle.

Generally, a sag of 8-10% of the span length is good if clearance permits. The sag is constrained by the necessity to avoid being snagged by floating debris or landslides at high water. 8-10% is the target sag because it allows the cable to perform at its greatest strength: the strongest shape for an arch is a parabola, and the cable serves as the main arch for the crossing. Using more or less sag is not recommended because it would compromise the parabolic shape of the arch.

## Plan:
The problem outlined above includes both design and implementation issues. Our primary goal is to create a python framework which can process an excel input and turn it in to an output for the builder. The excel input will contain all necessary variables for the python to run. The output will contain all the information needed for the maestro to build the aerial crossing, and we will attempt to provide a visual as well, such as a profile view of the crossing.

For the design aspect, we will follow the procedure outlined in Appendix E of “Handbook of Gravity-Flow Water Systems” by Thomas Jordan. This appendix contains a design procedure that we will implement in Python. It covers basic calculations, anchor design, clamping, sheathing, and an example that we can follow. All the equations have already been put into python format, and the example successfully runs. Our remaining tasks include working on reading an excel input and creating a simple but comprehensive output, as well as clarifying a few assumptions made in the handbook.

Our project’s focus on implementation will result in its successful application to Chris’s work. We look forward to gaining experience about what is useful in practice and applying our new python knowledge to a real world example.

![pipelineCrossing](https://github.com/DesireeJSausele/CEE4520-CLAD-Design-Project/blob/master/Images/Aerial_pipeline_crossing.png?raw=true)
Figure 1. Variables for Suspension Calculations



The following constants and equations come from Thomas Jordan's "Handbook of Gravity-Flow Water Systems" (1980) and are derived from the equations for the catenary.

Inputs needed:
Y=vertical sag of cable [m] - the cable must not sag so much that it will get snagged by floating debris or landslides; a sag of 8-10% of the span length is good if clearance permits
Arbitrary selection of the cable - see chapter 11 of Handbook of Civil Engineering

###Crossing calculations:
####Define:

* $\text{Wc=weight per length of cable [kg/m]}$
* $\text{Wp=weight per length of pipe [kg/m]}$
* $\text{Ww=weight per length of water in pipe [kg/m]}$
* $F_{wind} = \text{wind force}$
* $\text{t=horizontal tension in cable at midspan [kg]}$
* $\text{S=length of span between anchors [m]}$
* $\text{Y=vertical sag of cable [m]}$
* $\text{B=angle between horizontal and tension vector [degrees]}$
* $\text{L=total length of cable including anchoring [m]}$
* $\text{SF=safety factor; value is typically 4}$
* $SF_{wind}=\text{recommended safety factor for additional forces of wind and sway}$
* $\text{T=total tension in cables at anchors [kg]}$

#### Calculate:
Estimates the wind force exerted on the system
$$F_{wind} = SF_{wind}* (W_c+ W_p+ W_w)$$

W is the total weight of the cable pipe system with water included

$$W= W_c+ W_p+ W_w+ F_{wind}$$

Calculates the horizontal tension in the cable

$$t = \frac{W*S^2}{8Y} (N)$$

Calculates the angle of tension

$$B = arctan\frac{4Y}{S} (degrees)$$

Calculates the entire tension in the cables at anchors
$$T = \frac{SF*t}{cos(B)} (kg)$$

Calculates the total length of cable needed
$$L = S * (1 + \frac{8Y^2}{3S^2})$$

###Anchor calculations:
####Define:
$$W_{anchor} = \text{total weight of anchor [kg]}$$
$$W_{drystone} = \text{total weight of drystone needed [kg]}$$
$$\mu = \text{frictional characteristic of soil type}$$
$$\delta = \text{density of drystong [kg/}m^3]$$
$$W_{anchor} = \frac{Tcos\theta}{\mu} + T sin\theta$$
$$W_{drystone} = \frac{Tcos\theta}{\mu} + T sin\theta$$
$$V_{drystone} = \frac{W_{drystone}}{\delta}$$


Appendix E is displayed below for reference:
![AppendixE1](https://github.com/DesireeJSausele/CEE4520-CLAD-Design-Project/blob/master/Images/appendixE1.png?raw=true)

![AppendixE2](https://github.com/DesireeJSausele/CEE4520-CLAD-Design-Project/blob/master/Images/appendixE2.png?raw=true)

![AppendixE3](https://github.com/DesireeJSausele/CEE4520-CLAD-Design-Project/blob/master/Images/appendixE3.png?raw=true)

![AppendixE4](https://github.com/DesireeJSausele/CEE4520-CLAD-Design-Project/blob/master/Images/appendixE4.png?raw=true)

![AppendixE5](https://github.com/DesireeJSausele/CEE4520-CLAD-Design-Project/blob/master/Images/appendixE5.png?raw=true)


```python
#functions
import math as math
#Wind forces, wind (kg/m)
def wind(Wc, Wp, Ww):
  wind= 0.15* (Wc+ Wp+ Ww)
  return wind

#Total weight of length of crossing, W (kg/m)
def W(Wc, Wp, Ww, wind):
  W= Wc+ Wp+ Ww+ wind
  return W

#Horizontal tension, t (kg)
#Y=vertical sag of cable (meters)
#S=length of span (between anchors) (meters)
def t(W, S, Y):
  t=(W*S**2)/(8*Y)
  return t

#Angle of tension, B (degrees)
def B(Y, S):
  B=((math.atan(4*Y/S))*u.radians).to(u.degrees)
  return B

#Total Tension, T (kg)
#SF= safety factor (example uses 4)
def T(SF, t, B):
  T=(SF*t)/(math.cos(B))
  return T

#check that T<Tcable
def T_check(T,T_cable):
  if T<T_cable:
    T_check=1
  else:
    T_check=0
  return T_check

#Required length of cable, L (meters)
def L_cable(S, Y, Anchoring):
  L_cable= S* (1+ ((8*Y**2)/(3*S**2)))
  return L_cable

#anchors
def L_total(L_cable,anchor_length):
  L_total=L_cable+anchor_length
  return L_total

def mu(SoilType):
  if SoilType=='Coarse Grain (w/o silt/clay)':
    mu=0.55
  if SoilType=='Coarse Grain (with silt/clay)':
    mu=0.45
  if SoilType=='Silt or Clay':
    mu=0.35
  if SoilType=='Firm Rock (roughened surface)':
    mu=0.60
  return mu

def W_anchor(T,theta,mu):
  W_anchor=(T*math.cos(theta)/mu)+T*math.sin(theta)
  return W_anchor

def W_add_masonry(W_anchor,W_masonry):
  W_drystone=W_anchor-W_masonry
  return W_add_masonry

def Vol_add_masonry(W_add_masonry,density_add_masonry):
  Vol_add_masonry=W_add_masonry/density_add_masonry
  return Vol_add_masonry

def post_anchor_size(t):
  if t<68*u.kg:
    post_anchor_size='1" GI pipe'
  elif t<151*u.kg and t>=68*u.kg:
    post_anchor_size='1.5" GI pipe'
  elif t<270*u.kg and t>=151*u.kg:
    post_anchor_size='2" GI pipe'
  elif t<678*u.kg and t>=270*u.kg:
    post_anchor_size='3" GI pipe'
  return post_anchor_size

def add_masonry_density(masonry_type):
  if masonry_type=='Brick':
    masonry_density=2120*u.kg/u.m**3
  if masonry_type=='Stone':
    masonry_density=2450*u.kg/u.m**3
  if masonry_type=='Dry Stone':
    masonry_density=2000*u.kg/u.m**3
  return(masonry_density)


def Cable_info(cable_core,cable_strength,cable_size):
  #This function returns the tension allowed in the selected cable and its corresponding weight

  cables = ['1/4"','5/16"','3/8"','7/16"','1/2"','9/16"','5/8"','3/4"','7/8"','1"']

  #cable_vals provides information on tension allowed by cable and weight of cable. Tension info is in the first row and weight info is in the second. It is ordered by increasing cable size in the same order as the info in the cables array.

  #These numbers must have units. If they have units, then add the units to the arrays. Use numpy arrays rather than lists.

  IPS_IWRC_vals = [[2.94, 4.58, 6.56, 8.89, 11.5, 14.5, 17.9, 25.6, 34.6, 44.9],[0.116, 0.18, 0.26, 0.35, 0.46, 0.59, 0.72, 1.04, 1.42, 1.85]]
  IPS_FC_vals = [[2.74, 4.26, 6.1, 8.27, 10.7, 13.5, 16.7, 23.8, 32.2, 41.8],[0.105, 0.164, 0.236, 0.32, 0.42, 0.53, 0.66, 0.95, 1.29, 1.68]]
  EIPS_vals = [[3.4, 5.27, 7.55, 10.2, 13.3, 16.8, 20.6, 29.4, 39.8, 51.7],[0.116, 0.18, 0.26, 0.35, 0.46, 0.59, 0.72, 1.04, 1.42, 1.85]]

  i = 0
  length = len(cables)
  for i in range(length):
    if cable_size == cables[i]:
      index = i
    else:
      i = i + 1

  if cable_strength == 'IPS':
    if cable_core == 'IWRC':
      T_cable = IPS_IWRC_vals[0][index]
      Wc =  IPS_IWRC_vals[1][index]
    elif cable_core == 'FC':
      T_cable = IPS_FC_vals[0][index]
      Wc =  IPS_FC_vals[1][index]
  elif cable_strength =='EIPS':
    T_cable = EIPS_vals[0][index]
    Wc =  EIPS_vals[1][index]
  Cable_info = [(T_cable*u.tons).to(u.kg), (Wc*u.pound/u.ft).to(u.kg/u.m)]

  return(Cable_info)
```

```python
#example problem
import pandas as pd
import numpy as np
import xlrd as xlrd
import xlwt as xlwt
from aguaclara.core.units import unit_registry as u
from aguaclara.core import physchem as pc
from aguaclara.core import utility as ut
import matplotlib.pyplot as plt

#load from excel
#Excel workbook and python script must be in same folder
workbook= xlrd.open_workbook('Alumbrador-2019-Final.xlsm', on_demand = True)
wksht_aerialcross=workbook.sheet_by_name('Python Inputs')

#load crossing EST
#What is EST? Are these dimensionless values?
cross_A1=wksht_aerialcross.cell(2,0).value
cross_A2=wksht_aerialcross.cell(2,1).value
cross_B1=wksht_aerialcross.cell(3,0).value
cross_B2=wksht_aerialcross.cell(3,1).value

#load cable information
cable_size=wksht_aerialcross.cell(2,2).value #this loads in the " which will be problematic
print(cable_size)
cable_core=wksht_aerialcross.cell(2,3).value
print(cable_core)
cable_strength=wksht_aerialcross.cell(2,4).value
print(cable_strength)
Cable_data = Cable_info(cable_core,cable_strength,cable_size)
print(Cable_data)
T_cable = Cable_data[0]
sag_percent=wksht_aerialcross.cell(2,5).value

Wc = Cable_data[1]
print(Wc)
Wp=13.77*u.kg/u.m
Ww=5.32*u.kg/u.m
S=16.57*u.m

Y=(sag_percent/100*S)
T_val=999999999999*u.kg #define as very large so that while loop iterates at least once
SF=wksht_aerialcross.cell(2,6).value
Anchoring=(wksht_aerialcross.cell(2,7).value)*u.m
SoilType=wksht_aerialcross.cell(2,12).value
W_masonry=630*u.kg

#The while loop below doesn't change the cable dimension and correct the cable weight with each iteration.
while T_val>T_cable-1*u.kg:
  wind_val= wind(Wc,Wp,Ww)
  W_val= W(Wc,Wp,Ww,wind_val)
  t_val= t(W_val,S,Y)
  B_val= B(Y,S)
  T_val= T(SF,t_val,B_val)

L_cable_val= L_cable(S,Y,Anchoring)
L_total_val=L_total(L_cable_val,Anchoring)
mu_val=mu(SoilType)
print(mu_val)

alpha=wksht_aerialcross.cell(2,9).value*u.m
beta=wksht_aerialcross.cell(2,10).value*u.m
theta=(math.asin(beta/alpha)*u.radians).to(u.degrees)

W_anchor_val=W_anchor(T_val,theta,mu_val)
add_masonry_type=beta=wksht_aerialcross.cell(2,11).value
add_masonry_density_val=add_masonry_density(add_masonry_type)
W_add_masonry_val=W_anchor_val-W_masonry
Vol_add_masonry_val=Vol_add_masonry(W_add_masonry_val,add_masonry_density_val)
post_anchor_size_val=post_anchor_size(t_val)


#write outputs to new workbook
output_names=np.array(['weight of pipe','weight of water','segment length','sag','wind force','horizontal tension','angle of tension','total tension','length of cable across crossing','total length of cable','soil constant','angle of cable from top of post to top of anchor','total weight of anchor','weight needed of additional masonry','volume of additional masonry','post anchor size'])
output_vars=np.array(['Wp [kg/m]','Ww [kg/m]','S [m]','Y [m]','wind [kg/m]','t [kg]','B [degrees]','T [kg]','L_cable [m]','L_total [m]','mu','theta [degrees]','W_anchor [kg]','W_add_masonry [kg]','Vol_add_masonry [m**3]','post_anchor_size'])
output_vals=np.array((Wp.magnitude,Ww.magnitude,S.magnitude,Y.magnitude,wind_val.magnitude,t_val.magnitude,B_val.magnitude,T_val.magnitude,L_cable_val.magnitude,L_total_val.magnitude,mu_val,theta.magnitude,W_anchor_val.magnitude,W_add_masonry_val.magnitude,Vol_add_masonry_val.magnitude,post_anchor_size_val))

#run this entire block together
workbook = xlwt.Workbook()
outputs = workbook.add_sheet('Outputs')
for i in range(0,16):
  outputs.write(0,i,output_names[i])
  outputs.write(1,i,output_vars[i])
  outputs.write(2,i,output_vals[i])
workbook.save('Outputs.xls')

```
##Profile View for Aerial Crossing:
```Python
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
wksht_graph=workbook.sheet_by_name('Graph Inputs')

#Inputs (all values in units of meters):
Elevation_Station1= wksht_graph.cell(2,0).value #elevation in meters
Elevation_Station2= wksht_graph.cell(2,1).value #elevation in meters
Min_post_height= wksht_graph.cell(2,2).value #meters
Post1_PipeExtension= wksht_graph.cell(2,3).value #distance pipe extends after post 1 in meters
Post2_PipeExtension= wksht_graph.cell(2,4).value #distance pipe extends after post 2 in meters
X= wksht_graph.cell(2,5).value #distance from pipe to bottom of cable sag (if cable touching pipe then X=0)
Obstacle_elevation= wksht_graph.cell(2,6).value #meters
Obstacle_position= wksht_graph.cell(2,7).value #obstacle position along the segment in meters
Obstacle_width= wksht_graph.cell(2,8).value #meters
Highwater_elevation= wksht_graph.cell(2,9).value #meters
Highwater_width= wksht_graph.cell(2,10).value #meters
Post1_Anchor_height= wksht_graph.cell(2,11).value #height from top of post to top of anchor in meters
Post1_Anchor_distance= wksht_graph.cell(2,12).value #distance from top of post to top of anchor in meters
Post2_Anchor_height= wksht_graph.cell(2,13).value #height from top of post to top of anchor in meters
Post2_Anchor_distance= wksht_graph.cell(2,14).value #distance from top of post to top of anchor in meters
Standard_Slab= wksht_graph.cell(2,15).value#only if using concrete anchors

S_dimensionless= S.magnitude
Y_dimensionless= Y.magnitude

#Post
Difference_elevation= abs(Elevation_Station1-Elevation_Station2)
Height_post_highside= Min_post_height
Height_post_lowside= Min_post_height+ Difference_elevation
Bottom_Post_Elevation_1= Elevation_Station1
Bottom_Post_Elevation_2= Elevation_Station2
#Compensate the Post Elevation if pipe would be below minimum pipe level required
if Elevation_Station1 < Elevation_Station2:
    Top_Post_Elevation_Station1= Elevation_Station1+ Height_post_lowside
else:
  Top_Post_Elevation_Station1= Elevation_Station1+ Height_post_highside
Top_Post_Elevation_Station1

if Top_Post_Elevation_Station1-Y_dimensionless < Highwater_elevation:
    Top_Post_Elevation_Station1=Top_Post_Elevation_Station1+abs(Top_Post_Elevation_Station1-Highwater_elevation)
else:
   Top_Post_Elevation_Station1= Top_Post_Elevation_Station1
Top_Post_Elevation_Station1

Top_Post_Elevation_Station2= Top_Post_Elevation_Station1
#first support
plt.vlines(-.5*S_dimensionless, Bottom_Post_Elevation_1, Top_Post_Elevation_Station1, color='brown', linewidth=3)
#first support
plt.vlines(S_dimensionless-.5*S_dimensionless, Bottom_Post_Elevation_2, Top_Post_Elevation_Station2, color='brown', linewidth=3)

#Cable
x= [-.5*S_dimensionless, (S_dimensionless/2)-.5*S_dimensionless, S_dimensionless-.5*S_dimensionless]
y= [Top_Post_Elevation_Station1, -Y_dimensionless+Top_Post_Elevation_Station1, Top_Post_Elevation_Station2]
f= interp1d(x, y, kind='quadratic')
x_interpol= np.linspace(-.5*S_dimensionless, S_dimensionless-.5*S_dimensionless, 1000)
y_interpol= f(x_interpol)
plt.plot(x_interpol, y_interpol, label='cable')
plt.scatter(x_interpol[0],y_interpol[999], color='blue')
plt.scatter(x_interpol[999],y_interpol[999], color='blue')

#Pipe
plt.hlines(-Y_dimensionless+Top_Post_Elevation_Station1-X, -.5*S_dimensionless-Post1_PipeExtension, S_dimensionless-.5*S_dimensionless+Post2_PipeExtension, label='pipe')

#Cable clamps
#First clamp
plt.vlines(-.5*S_dimensionless,Bottom_Post_Elevation_1, y_interpol[0],color='green',label='cable clamps')
#Last clamp
plt.vlines(S_dimensionless-.5*S_dimensionless,Bottom_Post_Elevation_2, y_interpol[999],color='green')
#Clamps in between (one meter apart from each other)
for i in range (1, math.floor(S_dimensionless)):
  plt.vlines(-.5*S_dimensionless+1*i, -Y_dimensionless+Top_Post_Elevation_Station1-X, f(-.5*S_dimensionless+1*i),color='green')
#re-plot post with the cable clamps
#first support
plt.vlines(-.5*S_dimensionless, Bottom_Post_Elevation_1, Top_Post_Elevation_Station1, color='brown',label='post', linewidth=3)
#first support
plt.vlines(S_dimensionless-.5*S_dimensionless, Bottom_Post_Elevation_2, Top_Post_Elevation_Station2, color='brown', linewidth=3)


#Obstacle Elevation (river, stream, gorge, landslide chute, difficult/rocky terrain)
Obstacle_x_mid= -0.5*S_dimensionless+ Obstacle_position
Obstacle_x1= Obstacle_x_mid-(0.5*Obstacle_width)-.2
Obstacle_x2= Obstacle_x_mid+(0.5*Obstacle_width)-.2
Obstacle_x= [Obstacle_x1, Obstacle_x_mid, Obstacle_x2]
Obstacle_y= [Obstacle_elevation, Obstacle_elevation, Obstacle_elevation]
plt.plot(Obstacle_x,Obstacle_y, color='orange', label='obstacle')

#High Water Mark
Highwater_x_mid= -0.5*S_dimensionless+Obstacle_position
Highwater_x1= Highwater_x_mid-(0.5*Highwater_width)-.3
Highwater_x2= Highwater_x_mid+(0.5*Highwater_width)-.5
Highwater_x= [Highwater_x1, Highwater_x_mid, Highwater_x2]
Highwater_y= [Highwater_elevation, Highwater_elevation, Highwater_elevation]
plt.plot(Highwater_x,Highwater_y, color='red', label='highwater')

#Min Pipe
Min_Pipe_Elevation= Highwater_elevation+2
Min_pipe_x_mid= -0.5*S_dimensionless+Obstacle_position
Min_pipe_x1= Min_pipe_x_mid-(0.5*Obstacle_width)
Min_pipe_x2= Min_pipe_x_mid+(0.5*Obstacle_width)
Min_Pipe_x= [Min_pipe_x1, Min_pipe_x_mid, Min_pipe_x2]
Min_Pipe_y= [Min_Pipe_Elevation, Min_Pipe_Elevation, Min_Pipe_Elevation]
plt.plot(Min_Pipe_x, Min_Pipe_y, color='gray', label='minimum pipe')

#Standard Anchor 1
x_anchor1= [-0.5*S_dimensionless-0.2, -0.5*S_dimensionless-0.2, -0.5*S_dimensionless+0.2, -0.5*S_dimensionless+0.2, -0.5*S_dimensionless-0.2]
y_anchor1= [Elevation_Station1, Elevation_Station1-1, Elevation_Station1-1, Elevation_Station1, Elevation_Station1]
plt.plot(x_anchor1, y_anchor1, color='brown', label= 'standard anchor', linestyle='dashed')
#Standard Anchor 2
x_anchor2= [0.5*S_dimensionless-0.2, 0.5*S_dimensionless-0.2, 0.5*S_dimensionless+0.2, 0.5*S_dimensionless+0.2, 0.5*S_dimensionless-0.2]
y_anchor2= [Elevation_Station2, Elevation_Station2-1, Elevation_Station2-1, Elevation_Station2, Elevation_Station2]
plt.plot(x_anchor2, y_anchor2, color='brown', linestyle='dashed')

#If the anchor type is Cement Masonry Block
type_anchor=wksht_aerialcross.cell(2,8).value
if type_anchor == 'Cement Masonry Block':
  #Standard Anchor Cable 1
  x1= [-.5*S_dimensionless, -.5*S_dimensionless-Post1_Anchor_distance]
  y1= [Top_Post_Elevation_Station1, Top_Post_Elevation_Station1-Post1_Anchor_height]
  plt.plot(x1, y1, color='brown', label= 'anchor')

  #Standard Anchor Cable 2
  x2= [0.5*S_dimensionless, 0.5*S_dimensionless+ Post2_Anchor_distance]
  y2= [Top_Post_Elevation_Station2, Top_Post_Elevation_Station2-Post2_Anchor_height]
  plt.plot(x2, y2, color='brown')

  #Anchor 1
  x_concrete1= [-0.5*S_dimensionless-Post1_Anchor_distance-0.75*Standard_Slab, -0.5*S_dimensionless-Post1_Anchor_distance-0.75*Standard_Slab, -0.5*S_dimensionless-Post1_Anchor_distance-0.75*Standard_Slab+Standard_Slab, -0.5*S_dimensionless-Post1_Anchor_distance-0.75*Standard_Slab+Standard_Slab, -0.5*S_dimensionless-Post1_Anchor_distance-0.75*Standard_Slab]
  y_concrete1= [Top_Post_Elevation_Station1-Post1_Anchor_height, Top_Post_Elevation_Station1-Post1_Anchor_height-Standard_Slab, Top_Post_Elevation_Station1-Post1_Anchor_height-Standard_Slab, Top_Post_Elevation_Station1-Post1_Anchor_height, Top_Post_Elevation_Station1-Post1_Anchor_height]
  plt.plot(x_concrete1, y_concrete1, color='purple', linestyle= 'dashed')

  #Anchor 2
  Concrete_side_2=Vol_add_masonry_val.magnitude**(1/3)
  x_concrete2=[0.5*S_dimensionless+Post2_Anchor_distance+0.75*Concrete_side_2, 0.5*S_dimensionless+Post2_Anchor_distance+0.75*Concrete_side_2, 0.5*S_dimensionless+Post2_Anchor_distance+0.75*Concrete_side_2-Concrete_side_2, 0.5*S_dimensionless+Post2_Anchor_distance+0.75*Concrete_side_2-Concrete_side_2, 0.5*S_dimensionless+Post2_Anchor_distance+0.75*Concrete_side_2]
  y_concrete2= [Top_Post_Elevation_Station2-Post2_Anchor_height, Top_Post_Elevation_Station2-Post2_Anchor_height-Concrete_side_2, Top_Post_Elevation_Station2-Post2_Anchor_height-Concrete_side_2, Top_Post_Elevation_Station2-Post2_Anchor_height, Top_Post_Elevation_Station2-Post2_Anchor_height]
  plt.plot(x_concrete2, y_concrete2, color='purple', linestyle= 'dashed', label='concrete anchor')

  plt.legend(bbox_to_anchor=(1, 1))
  plt.savefig('Aerial Crossing.png')
  plt.xlabel('Distance (m)', fontsize=20)
  plt.ylabel('Elevation (m)', fontsize=20)
  plt.title('Aerial Crossing', fontsize=20)
  plt.show()
else:
  plt.legend(bbox_to_anchor=(1, 1))
  plt.xlabel('Distance (m)', fontsize=20)
  plt.ylabel('Elevation (m)', fontsize=20)
  plt.title('Aerial Crossing', fontsize=20)
  #change figure name each time this is run!!!!
  plt.savefig('CEE4520-CLAD-Design-Project/Images/Aerial Crossing.png')
  plt.show()
```

## Future Work

While this project has accomplished many of our team's original goals, lots of new ideas emerged while we were working. Below is a summary of features that could be added to this project by future teams.
  - Link to OnShape for 3D rendering of concrete blocks, including rebar structure.
  - Exploration of non-level pipe crossings.
  - Expand on the material properties of the pipe csv file and code to include data on the cables as well.



##Citations:
Jordan, T. (1980). A Handbook of Gravity-Flow Water Systems for Small Communities. Nepal: United Nations Children's Fund.
